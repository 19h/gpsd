= GPSD Time Service HOWTO =
Gary E. Miller <gem@rellim.com>, Eric S. Raymond <esr@thyrsus.com>
v0.1, October 2013

This document is mastered in asciidoc format.  If you are reading it in HTML,
you can find the original at the GPSD project website.

== Introduction ==

GPSD, NTP and a GPS supplying 1PPS output can be used to set up a
high-quality NTP time server. This HOWTO explains the method and
various options you have in setting it up.

The document you see is a draft in progress. We would like to produce
a comprehensive guide suitable for people who know little about time
service. We encourage others to contribute additions and corrections.

.Units table
|=================================================
| ns    | nanosecond  | One billionth of a second
| &mu;s | microsecond | One millionth of a second
| ms    | millisecond | One thousandth of a second
|=================================================

== How NTP Works ==

NTP (Network Time Protocol) is a set of services that attempts to
synchronize computer clocks across the Internet - ultimately, to the
master atomic clock at the U.S. Naval Observatory.

NTP service daemons running on each host do clock synchronization in
the presence of variable network latency by monitoring those delays in
real time and passing around messages that say, essentially, "I
believe it is time X and that my propagation delay to you is Y".
Each daemon then uses rather complex algorithms that we won't attempt
to describe here to digest incoming messages into a composite "NTP time".

NTP conditions your system clock by noticing how your system clock
time differs from deduced NTP time, then speeding up or slowing down
your clock's tick rate until it is resynchronized.  (These tick-rate
changes are extremely small, much too small for a human or even most
software timing loops to ever notice.)

Most computers are just NTP clients.  They take NTP notifications from
a set of servers (which on a Linux system is described by a list in
/etc/ntp.conf or possibly /etc/default/ntpdate) and use it to adjust
the local clock.  It is generally expected that NTP clients will have
an accuracy (that is, maximum divergence from the master atomic clock)
of +0-10ms.

With GPSD and a suitable GPS, you can locally condition your clock to
higher accuracy than received NTP time, and possibly serve that to
other systems.

== 1PPS quality issues ==

GPSD is useful for precision time service because it can use the 1PPS
pulse delivered by some GPSes to condition time delivered by NTP.

GPS satellites deliver a top-of-GPS-second notification that is
nominally accurate to 50ns. 1PPS-capable GPSes use an RS-232 control
line to mark the 1PPS edge of second (usually Carrier Detect or Ring
Indicator; GPSD will quietly accept either).  Under Linux there are
two ways to watch 1PPS; Kernel PPS (KPPS) and plain PPS. These have
very different error budgets.

Kernel PPS uses a kernel function to accurately timestamp the status
change on the PPS line.  Basic PPS has the kernel wake up the PPS
thread and then the PPS thread reads the current system clock.  As
noted in the GPSD code, having the kernel do the time stamp yields
lower latency and less jitter. Both methods have accuracy degraded by
interrupt-processing latency in the kernel serial layer, but plain
PPS incurs additional context-switching overhead that KPPS does not.

With KPPS it is very doable to get the system clock stable to +-1
&mu;sec.  Otherwise you are lucky to get +-5 ms, and there will be
about 20&mu;s of jitter. All these figures were observed on
plain-vanilla x86 PCS with clock speeds in the 2GHz range.

All the previous figures assume you're using PPS delivered over RS232.
USB GPSes that deliver 1PPS are rare, but do exist. Notably, there's
the Navsys GR601-W (designed by one of us, as it happens). In case
this device goes out of production it's worth noting that it's a
trivial modification of the stock two-chip-on-a-miniboard
commodity-GPS design of engine plus USB-to-serial adapter; the GR601-W
wires a UBlox 6 to a Prolific Logic PL23203.  To get 1PPS out, just
wire the 1PPS pin from the engine to the Carrier Detect pin on the USB
adapter.

With this design, 1PPS from the engine will turn into a USB event that
become visible to the host system (and GPSD) the next time the USB
device is polled. USB polling intervals vary but on the GR601-W you
can expect 1ms accuracy; this is typical.

.Summary of latency sources
|===================================
| GPS atomic clock  |  +-50ns
| KPPS              |  +-1&mu;s
| PPS               |  +-5ms
| USB poll interval |  +-1ms
|===================================

TODO: How specific can we be about jitter?

== Interfacing with NTPD ==

The NTP daemon on your system will accept conditioning inputs from
local time sources


== KPPS and Security ==

On Linux, KPPS requires root permissions.  In order to present the
smallest possible attack surface to privilege-escalation attempts, gpsd
run as root drops its root privileges very soon after startup - just
after it has opened any serial device paths passed on the command line.
Thus, KPPS can only be used with devices passed that way, not with
GPSes that are later presented to gpsd by the hotplug system.

== TODOs ==

TODO: Merge most of "USE WITH NTP" and "USE WITH CHRONY" from the
gpsd man page.

TODO: tutorial on how to choose NTPD offset parameters

Gary says:

gpsd needs root for several things during timekeeping initialization:
        to give itself a high priority for minimal latency timekeeping.
        to access KPPS
        to access PPS on the GPS port if the port permissions are odd
        to select and access/create the proper ntpd shmget() units
        to select and access/create the proper chronyd socket file

At the moment proper timekeeping initialization can only happen when
gpsd is just started (ATM that is slightly broken).  If a device
is hotplugged into a runing gpsd initialization of KPPS is not
possible, the PPS device may not be accesible and the SHMs and sockets
will be different or unavailable.

If I had my druthers, gpsd<->ntpd would use the chronyd socket
mechanism.  It is a much simpler and robust method.  Given the LFSSTD
t still needs to put the socket in different places depending on
root/non-root operation.

I would also add the comments in ntpshm.c starting on lines 78 and 865.

The only thing missing would be some help on enabling KPPS in the kernel
and getting time_pps.h installed.

ckuethe could contribute info on how this all works with BSD.

> > A brief tutorial on how to choose NTPd offset parameters would be good
> > to have in the HOWTO, too.  Basically I want this to be a primer for
> > the relatively ignorant - like, er, me.
>
> One could argue that is out of our scope as it is in the ntp.conf
> file.  Basically you get several good chimers and adjust fudges until
> they all agree.  From what I can tel no one really does it right.

> > There's a reference to it in a comment
> > in ntpshm.c, but it didn't tell me eniough to understand *why*.
>
> One very basic issue, is that the mechanism gpsd uses to communicate
> to ntpd or chronyd differs depending on whether gpsd is root or not.
>
> Note the code and coments in ntpshm.c starting on lines 190 and 664.
>
> Or just search for all usage of getuid() in ntpshm.c


//Reviewers: Gerry Creager <gerry.creager@noaa.gov>, Hal Murray <hmurray@megapathdsl.net>
