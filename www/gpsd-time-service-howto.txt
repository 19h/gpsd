= GPSD Time Service HOWTO =
Gary E. Miller <gem@rellim.com>, Eric S. Raymond <esr@thyrsus.com>
v0.1, October 2013

This document is mastered in asciidoc format.  If you are reading it in HTML,
you can find the original at the GPSD project website.

== Introduction ==

GPSD, NTP and a GPS supplying 1PPS output can be used to set up a
high-quality NTP time server. This HOWTO explains the method and
various options you have in setting it up.

The document you see is a draft in progress. We would like to produce
a comprehensive guide suitable for people who know little about time
service. We encourage others to contribute additions and corrections.

.Units table
|====================================================
| nSec    | nanoSecond  | 1/1,000,000,000 of a second
| uSec    | microSecond | 1/1,000,000 of a second
| mSec    | milliSecond | 1/1,000 of a second
|====================================================

== How NTP Works ==

NTP (Network Time Protocol) is a set of protocols that attempts to
synchronize computer clocks across the Internet - ultimately, to the
master atomic clock at the U.S. Naval Observatory.  NTP Version 3 is
defined in <<RFC-1305>>.

NTP service daemons running on each host do clock synchronization in
the presence of variable network latency by monitoring those delays in
real time and passing around messages that say, essentially, "I
believe it is time X and that my propagation delay to you is Y".
Each daemon then uses rather complex algorithms that we won't attempt
to describe here to digest incoming messages into a composite "NTP time".

NTP conditions your system clock by noticing how your system clock time
differs from deduced NTP time, then speeding up or slowing down your
clock's tick rate until it is resynchronized.  These tick-rate changes
are usually extremely small, much too small for a human or even most
software timing loops to ever notice. But large changes are possible.

Most computers are just NTP clients.  They take NTP notifications from
a set of servers (which on a Unix system is described by a list in
/etc/ntp.conf or possibly /etc/default/ntpdate) and use it to adjust
the local clock.  It is generally expected that NTP clients will have
an accuracy (that is, maximum divergence from the master atomic clock)
of &plusmn;100 mSec depending upon your network connnection.

Some NTP hosts are time *servers*.  These are known as "chimers".  They
use high-precision time sourced synchronized to the Naval Observatory
timebase to export reliable time for use by NTP clients.

You will hear time service people speak of "Stratum 0" (the reference
clocks) "Stratum 1" (NTP servers directly connected to reference
clocks over a path with known and compensated-for latency) and
"Stratum 2" (publicly accessible servers that get time from Stratum 1
over a network link.)  Ordinary computers are normally configured to
get time from one or more Stratum 2 servers.

With GPSD and a suitable GPS, you can locally condition your clock to
higher accuracy than internet received NTP time, and possibly serve that
to other systems.  

This would create your very own Stratum 1 server. Anyone can do this;
there is no official authority, and NTP clients may choose to use your
host as a chimer. The time-service network is self-regulating, with
NTP daemons constantly pruning statistical outliers so the timebase
cannot be accidentally or deliberately compromised.

In fact many public and widely-trusted Stratum 1 chimers use GPSes as
their Stratum 0, and a significant fraction of those use GPSD in the
way we will describe here.

TODO: Is it really true that most public NTP servers are Stratum 2, or
are there more layers?

== 1PPS quality issues ==

GPSD is useful for precision time service because it can use the 1PPS
pulse delivered by some GPSes to condition time delivered by NTP.

GPS satellites deliver a top-of-GPS-second notification that is
nominally accurate to 50nSec. 1PPS-capable GPSes often use an RS-232
control line to ship the 1PPS edge of second to the host system (usually
Carrier Detect or Ring Indicator; GPSD will quietly accept either).
Satellite top-of-second loses some accuracy on the way down due mainly
to variable delays in the ionophere; processing overhead in the GPS
itself adds a bit more latency, and your server detecting that pulse add
still more latency.  But it's still often accurate to on the order of 1
uSec.

Under most Unixes there are two ways to watch 1PPS; Kernel PPS (KPPS)
and plain PPS.  KPPS is formally known as RFC 2783 PPS.  These have
different error budgets.

Kernel PPS uses a kernel function to accurately timestamp the status
change on the PPS line.  Basic PPS has the kernel wake up the PPS
thread and then the PPS thread reads the current system clock.  As
noted in the GPSD code, having the kernel do the time stamp yields
lower latency and less jitter. Both methods have accuracy degraded by
interrupt-processing latency in the kernel serial layer, but plain
PPS incurs additional context-switching overhead that KPPS does not.

With KPPS it is very doable to get the system clock stable to &plusmn;1
uSec.  Otherwise you are lucky to get &plusmn;5 uSec, and there will be
about 20uSec of jitter. All these figures were observed on
plain-vanilla x86 PCS with clock speeds in the 2GHz range.

All the previous figures assume you're using PPS delivered over RS232.
USB GPSes that deliver 1PPS are rare, but do exist. Notably, there's
the Navsys GR601-W. In case this device goes out of production it's
worth noting that it's a trivial modification of the stock
two-chip-on-a-miniboard commodity-GPS design of engine plus
USB-to-serial adapter; the GR601-W wires a UBlox 6 to a Prolific Logic
PL23203.  To get 1PPS out, just wire the 1PPS pin from the engine to
the Carrier Detect pin on the USB adapter. (This is known as the
"Macx-1 mod".)

With this design, 1PPS from the engine will turn into a USB event that
becomes visible to the host system (and GPSD) the next time the USB
device is polled. USB polling intervals vary but on the GR601-W you
can expect 1ms accuracy; this is typical of USB 1.1 devices. 

.Summary of typical accuracy
|===================================
| GPS atomic clock  |  &plusmn;50nSec
| KPPS              |  &plusmn;1uSec
| PPS               |  &plusmn;5uSec
| USB poll interval |  &plusmn;1mSec
|===================================

As of late 2013 no USB GPS we know of implements the higher polling-rate
options in USB 2 and 3.  When one does, and if it has the Macx-1 mod,
higher USB accuracy will ensue.

TODO: How specific can we be about jitter?

== Choice of Hardware ==

To get 1PPS to your NTP daemon, you first need to get it from a
PPS-capable GPS. As of late 2013 this means either the previously
mentioned GR601-W or a serial GPS with 1PPS.

You can find 1PPs-capable devices supported by GPSD at <<HARDWARE>>.
Note that the most popular consumer-grade GPS engine - SiRF - does not
deliver 1PPS through USB or even RS232.  Thus the general run of cheap
GPS mice won't do.  In general, you can't use a USB device for time
service unless you know it has the Macx-1 mod.

In the past, the RS232 variant of the Garmin GPS-18 has been very
commonly used for time service.  While it is still a respectable
choice, newer devices have better sensitivity and signal
discrimination. This makes them superior for indoor use as time
sources.

Among newer receiver designs we've found the the uBlox 6 receiver
particularly good.  Unfortunately as of late 2013 this is still hard
to find in a packaged RS232 version, as opposed to an OEM module
exporting TTL levels or an eval kit costing a lot. Search the web; you
may find a here-today-gone-tomorrow offer on alibaba.com.  

== Feeding NTPD from GPSD ==

When gpsd receives a sentence with a timestamp, it packages the
received timestamp with current local time and sends it to a
shared-memory segment with an ID known to ntpd, the network time
synchronization daemon.  If ntpd has been properly configured to
receive this message, it will be used to correct the system clock.

If you're going to use gpsd for time service you must run in -n mode so
the clock will be updated even when no clients are active.

Note that deriving time from the date/time messages received from the
GPS is not as accurate as you might expect.  Messages are often
delayed in the receiver and on the link by as much as several hundred
mSec, and this delay is not constant.

//Hal: This is where a reference to SiRFs-are-bogus would be good.

On most OSes, gpsd includes support for interpreting the 1PPS pulses;
this can be used to update NTP at much higher accuracy than message
time provides.  You can determine whether your GPS emits this pulse,
and gpsd is detecting it, by running at -D 5 and watching for
carrier-detect state change messages in the logfile.  In addition, if
your kernel provides the RFC 2783 KPPS (kernel PPS) API then gpsd will
use that for extra accuracy.

Many Linux distributions have a package called "pps-tools" that will
install KPPS support and the time_pps.h header file.  We recommend you
do that.  If your kernel is built in the normal modular way, this
package installation will suffice.

If you are scratch-building your Linux kernel, the configuration 
must include these two lines:

-----------------------------------------------------------------------------
CONFIG_PPS=y
CONFIG_PPS_CLIENT_LDISC=y
-----------------------------------------------------------------------------

Other OSes have different ways to enable KPPS in their kernels.

On any system that supports KPPS, root permission is required for
initialization.  In order to present the smallest possible attack
surface to privilege-escalation attempts, gpsd run as root drops its
root privileges very soon after startup - just after it has opened any
serial device paths passed on the command line.  Thus, KPPS can only
be used with devices passed that way, not with GPSes that are later
presented to gpsd by the hotplug system.  

Those hotplug devices will, however, may be able to use plain,
non-kernel PPS. gpsd tries to automatically fall back to this when
absence of root permissions makes KPPS unavailable. This fallback is
complicated by the fact that gpsd needs to communicate to ntpd in
a different way in root and non-root mode.  This complicates the
configuration in ways beyond the scope of this document and is strongly
discouraged in practice.

Here is a sample ntp.conf configuration stanza telling ntpd how to
read the GPS notifications, when gpsd is started as root:

-----------------------------------------------------------------------------
server 127.127.28.0 
fudge 127.127.28.0 time1 0.420 refid GPS

server 127.127.28.1 prefer
fudge 127.127.28.1 refid GPS1
-----------------------------------------------------------------------------

Users of ntpd versions older than revision ntp-4.2.5p138 should instead use
this ntp.conf snippet, when gpsd is started as root:

-----------------------------------------------------------------------------
server 127.127.28.0 minpoll 4 maxpoll 4
fudge 127.127.28.0 time1 0.420 refid GPS

server 127.127.28.1 minpoll 4 maxpoll 4 prefer
fudge 127.127.28.1 refid GPS1
-----------------------------------------------------------------------------

The magic pseudo-IP address 127.127.28.0 identifies unit 0 of the ntpd
shared-memory driver; 127.127.28.1 identifies unit 1.  Unit 0 is used
for message-decoded time and unit 1 for the (more accurate, when
available) time derived from the PPS synchronization pulse.  Splitting
these notifications allows ntpd to use its normal heuristics to weight
them.  Different units (2 and 3, respectively) must be used when gpsd 
is not started as root.

With this configuration, ntpd will read the timestamp posted by gpsd
every 16 seconds and send it to unit 0.  The number after the
parameter time1 is an offset in seconds.  You can use it to adjust out
some of the fixed delays in the system.  gpsd builds in many offsets
but they are very GPS and CPU dependent.  

After starting as root ntpd, then gpsd, a line similar to the one below
should appear in the output of the command "ntpq -p" (after allowing the
GPS to acquire a 3D fix).  This may take up to 30 minutes if you GPS
has to cold start or has a poor sky view.

-----------------------------------------------------------------------------
remote	   refid      st t when poll reach  delay    offset  jitter
=========================================================================
+SHM(0)	  .GPS.      0 l   13   16  377    0.000    0.885   0.882
-----------------------------------------------------------------------------

If you are running PPS then it will look like this:

-----------------------------------------------------------------------------
remote	   refid      st t when poll reach  delay    offset  jitter
=========================================================================
-SHM(0)	  .GPS.      0 l   13   16  377    0.000    0.885   0.882
*SHM(1)	  .GPS1.     0 l   11   16  377    0.000   -0.059   0.006
-----------------------------------------------------------------------------

When the value under "reach" remains zero, check that gpsd is running;
cgps reports a 3D fix; and the '-n' option was used.  Some GPS can
report time with only one satellite but is almost all cases a 3D fix is
preferred or required.  Plain NMEA, no PPS, will also drive ntpd, but
the accuracy as bad as one second, or worse.  When the SHM(0) line does
not appear at all, check your ntp.conf and the system logs for error
messages from ntpd.

When no other reference clocks appear in the NTP configuration,
the system clock will lock onto the GPS clock, but this is a bad
configuration.  You should always have at least two other reference
clocks in your ntpd.conf for proper ntpd operation.  You want to adjust
the offsets (fudge) in your ntp.conf so the SHM(1) time is consistent
with your other reference clocks.  The gpsd developers would like to
receive information about the offsets (fudge) observed by users for each
type of receiver.  Please send us the output of the "ntpq -p" command
and the make and type of receiver.

When in doubt the preferred method to start your time keeping is:

$ su -
# killall -9 gpsd ntpd
# ntpd -gN
# sleep 2
# gpsd -n /dev/ttyXX
# sleep 2
# cgps

== Feeding chrony from GPSD ==

gpsd can provide reference clock information to chronyd similarly to the
way it talks to ntpd.  The advantage to using chrony is that the PPS
time resolution is in nanoseconds.  This is 1,000 times more precision
than the time resolution provided to ntpd.  When gpsd supports the new
ntpd protocol this difference will disappear, but chronyd is still
preferred.

gpsd, when run as root, talks to chronyd using a socket named
/var/run/chrony.ttyXX.sock (where ttyXX is replaced by the GPS device
name.  This allows multiple GPS to feed one chronyd.

No gpsd configuration is required to talk to chronyd.  To get chronyd
to connect to gpsd using the non-preferred SHM method add this to your
/etc/chrony/chrony.conf file:

-----------------------------------------------------------------------------
# delay 0.0 is right, but use 0.2 to avoid NMEA
# time fighting with PPS time
refclock SHM 0 offset 0.0 delay 0.2
refclock SHM 1 offset 0.0 delay 0.0
-----------------------------------------------------------------------------

To get chronyd to connect to gpsd using the more precise socket 
method add this to your /etc/chrony/chrony.conf file (replacing ttyXX
with your device name):  

If running as root:

-----------------------------------------------------------------------------
#refclock PPS
refclock SOCK /var/run/chrony.ttyXX.sock 
-----------------------------------------------------------------------------

If not running as root:  

-----------------------------------------------------------------------------
#refclock PPS
refclock SOCK /tmp/chrony.ttyXX.sock 
-----------------------------------------------------------------------------

== TODOs ==

TODO: tutorial on how to choose NTPD offset parameters

Gary says:

gpsd needs root for several things during timekeeping initialization:
        to give itself a high priority for minimal latency timekeeping.
        to access KPPS
        to access PPS on the GPS port if the port permissions are odd
        to select and access/create the proper ntpd shmget() units
        to select and access/create the proper chronyd socket file

At the moment proper timekeeping initialization can only happen when
gpsd is just started (ATM that is slightly broken).  If a device
is hotplugged into a runing gpsd initialization of KPPS is not
possible, the PPS device may not be accesible and the SHMs and sockets
will be different or unavailable.

If I had my druthers, gpsd<->ntpd would use the chronyd socket
mechanism.  It is a much simpler and robust method.  Given the LFSSTD
t still needs to put the socket in different places depending on
root/non-root operation.

I would also add the comments in ntpshm.c starting on lines 78 and 865.

ckuethe could contribute info on how this all works with BSD.

# > A brief tutorial on how to choose NTPd offset parameters would be good
# > to have in the HOWTO, too.  Basically I want this to be a primer for
# > the relatively ignorant - like, er, me.
#
# One could argue that is out of our scope as it is in the ntp.conf
# file.  Basically you get several good chimers and adjust fudges until
# they all agree.  From what I can tel no one really does it right.

# > There's a reference to it in a comment
# > in ntpshm.c, but it didn't tell me eniough to understand *why*.
#
# One very basic issue, is that the mechanism gpsd uses to communicate
# to ntpd or chronyd differs depending on whether gpsd is root or not.
#
# Note the code and coments in ntpshm.c starting on lines 190 and 664.
#
# Or just search for all usage of getuid() in ntpshm.c

== References ==

[bibliography]
- [[[RFC-1305] http://www.ietf.org/rfc/rfc1305.txt[Network Time Protocol (Version 3)]

- [[[STRATA]]] http://www.endruntechnologies.com/stratum1.htm[What Is Stratum 1?]

- [[[HARDWARE]]] http://catb.org/gpsd/hardware.html[Compatible Hardware]
