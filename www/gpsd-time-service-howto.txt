= GPSD Time Service HOWTO =
Gary E. Miller <gem@rellim.com>, Eric S. Raymond <esr@thyrsus.com>
v0.1, October 2013

This document is mastered in asciidoc format.  If you are reading it in HTML,
you can find the original at the GPSD project website.

== Introduction ==

GPSD, NTP and a GPS supplying 1PPS (pulse-per-second) output can be
used to set up a high-quality NTP time server. This HOWTO explains the
method and various options you have in setting it up.

The document you see is a draft in progress. We would like to produce
a comprehensive guide suitable for people who know little about time
service. We encourage others to contribute additions and corrections.

This document does not attempt to explain all the intricacies of
time service; it is focused on practical advice for one specific
deployment case.  An overview of the protocols can be found at
<<WIKI-NTP>>, and the official NTP FAQ <<NTP-FAQ>> is probably
as gentle an introduction as presently exists.

.Units table
|====================================================
| nSec    | nanoSecond  | 1/1,000,000,000 of a second
| uSec    | microSecond | 1/1,000,000 of a second
| mSec    | milliSecond | 1/1,000 of a second
|====================================================

== How NTP Works ==

NTP (Network Time Protocol) is a set of protocols that attempts to
synchronize computer clocks across the Internet - ultimately,
Universal Coordinated Time as defined by several scale-related atomic
clocks run by national standards institutes.  NTP Version 3 is defined
in <<RFC-1305>>.

NTP service daemons running on each host do clock synchronization in
the presence of variable network latency by monitoring those delays in
real time and passing around messages that say, essentially, "I
believe it is time X and that my propagation delay to you is Y".
Each daemon then uses rather complex algorithms that we won't attempt
to describe here to digest incoming messages into a composite "NTP time".

NTP conditions your system clock by noticing how your system clock time
differs from deduced NTP time, then speeding up or slowing down your
clock's tick rate until it is resynchronized.  These tick-rate changes
are usually extremely small, much too small for a human or even most
software timing loops to ever notice. But large changes are possible.

Most computers are just NTP clients.  They request NTP notifications from
a set of servers (which on a Unix system is described by a list in
/etc/ntp.conf or possibly /etc/default/ntpdate) and use it to adjust
the local clock.  It is generally expected that NTP clients will have
an accuracy (that is, maximum divergence from the master atomic clock)
of at most &plusmn;100 mSec, possibly less depending upon the quality 
of your network connection.

Some NTP hosts are time *servers*.  These are known as "chimers".  They
use high-precision time sourced synchronized to the Naval Observatory
timebase to export reliable time for use by NTP clients.

You will hear time service people speak of "Stratum 0" (the reference
clocks) "Stratum 1" (NTP servers directly connected to reference
clocks) and "Stratum 2" (publicly accessible servers that get time
from Stratum 1 over a network link). Stratum 3 chimers redistribute
time from Stratum 2, and so forth. There are defined higher strata up
to 15, but you will probably never see a public chimer higher than
Stratum 3.

Ordinary client computers are normally configured to get time from one
or more Stratum 2 (or less commonly Stratum 3) servers. With GPSD and
a suitable GPS, you can easily condition your clock to higher
accuracy than typical Stratum 2; with a little effort you can do
better than many public Stratum 1 servers.

You can then make your high-quality time available to other systems on
your network.  You can even join the fraternity of "time nuts" who run
public NTP servers for fun.  Anyone can do this; there is no official
authority, and NTP clients may choose to use your host as a
chimer. The time-service network is self-regulating, with NTP daemons
constantly pruning statistical outliers so the timebase cannot be
accidentally or deliberately compromised.

In fact many public and widely-trusted Stratum 1 chimers use GPSes as
their Stratum 0, and a significant fraction of those use GPSD in the
way we will describe here.

== 1PPS quality issues ==

GPSD is useful for precision time service because it can use the 1PPS
pulse delivered by some GPSes to correct a local NTP instance.

GPS satellites deliver a top-of-GPS-second notification that is
nominally accurate to 50nSec. 1PPS-capable GPSes often use an RS-232
control line to ship the 1PPS edge of second to the host system
(usually Carrier Detect or Ring Indicator; GPSD will quietly accept
either).  Satellite top-of-second loses some accuracy on the way down
due mainly to variable delays in the ionosphere; processing overhead
in the GPS itself adds a bit more latency, and your server detecting
that pulse add still more latency and jitter.  But it's still often
accurate to on the order of 1 uSec.

Under most Unixes there are two ways to watch 1PPS; Kernel PPS (KPPS)
and plain PPS latching.  KPPS is formally known as RFC 2783 PPS.  These have
different error budgets.

Kernel PPS uses a kernel function to accurately timestamp the status
change on the PPS line.  Basic PPS has the kernel wake up the PPS
thread and then the PPS thread reads the current system clock.  As
noted in the GPSD code, having the kernel do the time stamp yields
lower latency and less jitter. Both methods have accuracy degraded by
interrupt-processing latency in the kernel serial layer, but plain
PPS incurs additional context-switching overhead that KPPS does not.

With KPPS it is very doable to get the system clock stable to &plusmn;1
uSec.  Otherwise you are lucky to get &plusmn;5 uSec, and there will be
about 20uSec of jitter. All these figures were observed on
plain-vanilla x86 PCS with clock speeds in the 2GHz range.

All the previous figures assume you're using PPS delivered over RS232.
USB GPSes that deliver 1PPS are rare, but do exist. Notably, there's
the Navsys GR601-W. In case this device goes out of production it's
worth noting that it's a trivial modification of the stock
two-chip-on-a-miniboard commodity-GPS design of engine plus
USB-to-serial adapter; the GR601-W wires a uBlox 6 to a Prolific Logic
PL23203.  To get 1PPS out, just wire the 1PPS pin from the engine to
the Carrier Detect pin on the USB adapter. (This is known as the
"Macx-1 mod".)

With this design, 1PPS from the engine will turn into a USB event that
becomes visible to the host system (and GPSD) the next time the USB
device is polled. USB polling intervals vary but on the GR601-W you
can expect 1ms accuracy; this is typical of USB 1.1 devices. 

.Summary of typical accuracy
|=======================================
| GPS atomic clock    |  &plusmn;50nSec
| KPPS                |  &plusmn;1uSec
| PPS                 |  &plusmn;5uSec
| USB poll interval   |  &plusmn;1mSec
| Stratum 1 NTP time  |  &plusmn;10uSec
| Stratum 2 NTP time  |  &plusmn;100mSec
| Stratum 3 NTP time  |  &plusmn;200mSec
|=======================================

(Sources for the NTP accuracy bounds are <<STRATA>> and <<NTP-FAQ>>.)

As of late 2013 no USB GPS we know of implements the higher polling-rate
options in USB 2 and 3.  When one does, and if it has the Macx-1 mod,
higher USB accuracy will ensue.

TODO: How specific can we be about jitter?

== Choice of Hardware ==

To get 1PPS to your NTP daemon, you first need to get it from a
PPS-capable GPS. As of late 2013 this means either the previously
mentioned GR601-W or a serial GPS with 1PPS.

You can find 1PPs-capable devices supported by GPSD at <<HARDWARE>>.
Note that the most popular consumer-grade GPS engine - SiRF - does not
deliver 1PPS through USB or even RS232.  Thus the general run of cheap
GPS mice won't do.  In general, you can't use a USB device for time
service unless you know it has the Macx-1 mod.

In the past, the RS232 variant of the Garmin GPS-18 has been very
commonly used for time service.  While it is still a respectable
choice, newer devices have better sensitivity and signal
discrimination. This makes them superior for indoor use as time
sources.

In general, use a GPS with an RS232 interface for time service if you
can.  The GR601-W was designed (by one of the authors, as it happens)
for deployment with commodity TCP/IP routers that only have USB ports.
RS232 is more fiddly to set up, but it can deliver three orders of 
magnitude better accuracy and repeatability - enough to meet
prevailing standards for a public Stratum 1 chimer.

Among newer receiver designs we've found the the uBlox 6 receiver used
in the GR601-W to be particularly good.  Very detailed information on
its timing performance can be found at <<UBLOX-TIMING>>. One of us
(Raymond) has recent experience with an eval kit, the EVK 6H-0-001,
that would make an excellent Stratum 0 device.

Unfortunately as of late 2013 the uBlox 6 is still hard to find in a
packaged RS232 version, as opposed to a bare OEM module exporting TTL
levels or an eval kit like the EVK 6H-0-001 costing upwards of
US$300. Search the web; you may find a here-today-gone-tomorrow offer
on alibaba.com or somewhere similar.

The uBlox, and some other higher-end GPS receivers, has a stationary
mode which, after you initialize it with the device's location, can
deliver time service with only one good satellite lock (as opposed to
the three required for a fix in its normal mode). For most reliable
service we recommend using stationary mode. GPSD tools don't yet
directly support this, but that capability may be added in a future
release.

== Feeding NTPD from GPSD ==

Most Unix systems get their time service through ntpd, a very old and
stable open-source software suite which is the reference
implementation of NTP.  The project home page is <<NTP.ORG>>.

When gpsd receives a sentence with a timestamp, it packages the
received timestamp with current local time and sends it to a
shared-memory segment with an ID known to ntpd, the network time
synchronization daemon.  If ntpd has been properly configured to
receive this message, it will be used to correct the system clock.

Note that deriving time from the date/time messages received from the
GPS (without PPS) is not as accurate as you might expect.  Messages
are often delayed in the receiver and on the link by as much as
several hundred mSec, and this delay is not constant.  Under these
circumstances you can't expect accuracy to UTC better than 1 second. 

For example: SiRF receivers, the make currently most popular in
consumer-grade GPSes, exhibit a random wander of about 170mSec in the
offset between PPS and the transmission of the first sentence in each
reporting cycle. You can see this graphed at <<SIRF-WOBBLE>>.

On most OSes, gpsd includes support for interpreting the 1PPS pulses;
this can be used to update NTP at much higher accuracy than message
time provides.  You can determine whether your GPS emits this pulse,
and gpsd is detecting it, by running at -D 5 and watching for
carrier-detect state change messages in the logfile.  In addition, if
your kernel provides the RFC 2783 KPPS (kernel PPS) API gpsd will
use that for extra accuracy.

Note that gpsd assumes that after each fix the GPS will assert
1PPS first and ship sentences reporting time of fix second. Every
GPS we know of does things in this order.  If you ever encounter 
an exception, it should manifest as reported times that look like
they're from the future and require a negative fudge. If this
ever happens, please report the device make and model to the GPSD
maintainers so we can flag it in our GPS hardware database.

Many Linux distributions have a package called "pps-tools" that will
install KPPS support and the time_pps.h header file.  We recommend you
do that.  If your kernel is built in the normal modular way, this
package installation will suffice.

If you are scratch-building your Linux kernel, the configuration 
must include these two lines:

-----------------------------------------------------------------------------
CONFIG_PPS=y
CONFIG_PPS_CLIENT_LDISC=y
-----------------------------------------------------------------------------

Other OSes have different ways to enable KPPS in their kernels.

If you're going to use gpsd for time service, you must run in -n mode
so the clock will be updated even when no clients are active.

In order to present the smallest possible attack surface to
privilege-escalation attempts, gpsd run as root drops its root
privileges very soon after startup - just after it has opened any
serial device paths passed on the command line.

Thus, KPPS can only be used with devices passed that way, not with
GPSes that are later presented to gpsd by the hotplug system.  Those
hotplug devices will, however, may be able to use plain, non-kernel
PPS. gpsd tries to automatically fall back to this when absence of
root permissions makes KPPS unavailable.

In general, if you start gpsd as other than root, the following things
will happen that degrade the accuracy of reported time:

1. Devices passed on the command line will be unable to use KPPS and
will fall back to the same plain PPS that all hotplug devices must
use, increasing the associated error from ~1 uSec to about ~5 uSec.

2. gpsd will be unable to renice itself to a higher priority.  This
action helps protect it against jitter induced by variable system
load. It's particularly important if your NTP server is a general-use 
computer that's also handling mail or web service or development.

3. The way you have to configure ntpd and chrony will change away
from what we show you here; ntpd will need to be told different
shared-memory segment numbers, and chronyd will need a different
socket location.

You may also find gpsd can't open serial devices at all if your
OS distribution has done "secure" things with the permissions.

When in doubt, the preferred method to start your time keeping is:

$ su -
# killall -9 gpsd ntpd
# ntpd -gN
# sleep 2
# gpsd -n /dev/ttyXX
# sleep 2
# cgps

where /dev/ttyXX is whatever 1PPS-capable device you have.  In the
rest of these setup instructions will assume that you are starting
gpsd as root, with occasional glances at the non-root case.

Here is a minimal sample ntp.conf configuration telling ntpd how to
read the GPS notifications, when gpsd is started as root:

-----------------------------------------------------------------------------
server time-a.timefreq.bldrdoc.gov 
server bonehed.lcs.mit.edu 
server clock.sjc.he.net 

driftfile /var/lib/ntp/ntp.drift
logfile /var/log/ntp.log

# GPS Serial data reference
server 127.127.28.0 
fudge 127.127.28.0 time1 0.420 refid GPS

# GPS PPS reference
server 127.127.28.1 prefer
fudge 127.127.28.1 refid GPS1
-----------------------------------------------------------------------------

The first three servers are additional time references needed by ntpd
for redundancy and to give you a reference to see how well your local 
GPS is performing. 

Users of ntpd versions older than revision ntp-4.2.5p138 should instead use
this ntp.conf, when gpsd is started as root:

-----------------------------------------------------------------------------
server time-a.timefreq.bldrdoc.gov 
server bonehed.lcs.mit.edu 
server clock.sjc.he.net 

driftfile /var/lib/ntp/ntp.drift
logfile /var/log/ntp.log

# GPS Serial data reference
server 127.127.28.0 minpoll 4 maxpoll 4
fudge 127.127.28.0 time1 0.420 refid GPS

# GPS PPS reference
server 127.127.28.1 minpoll 4 maxpoll 4 prefer
fudge 127.127.28.1 refid GPS1
-----------------------------------------------------------------------------

The magic pseudo-IP address 127.127.28.0 identifies unit 0 of the ntpd
shared-memory driver; 127.127.28.1 identifies unit 1.  Unit 0 is used
for message-decoded time and unit 1 for the (more accurate, when
available) time derived from combining message-decoded time with the
PPS synchronization pulse.  Splitting these notifications allows ntpd
to use its normal heuristics to weight them. 

(Different units - 2 and 3, respectively - must be used when gpsd is not
started as root.)

With this configuration, ntpd will read the timestamp posted by gpsd
every 64 seconds (16 non-root) and send it to unit 0.  The number after
the parameter time1 is a "fudge", offset in seconds.  It's an estimate
of the latency between the time source and your ntpd. You can use it to
adjust out some of the fixed delays in the system.

To keep ntpd from preferring NMEA time over PPS time you can add an 
over large fudge to the NMEA time.

After starting as root ntpd, then gpsd, a line similar to the one below
should appear in the output of the command "ntpq -p" (after allowing the
GPS to acquire a 3D fix).  This may take up to 30 minutes if your GPS
has to cold start or has a poor skyview.

-----------------------------------------------------------------------------
     remote           refid      st t when poll reach   delay   offset  jitter
==============================================================================
xtime-a.timefreq .ACTS.           1 u   40   64  377   59.228   -8.503   0.516
-bonehed.lcs.mit 18.26.4.106      2 u   44   64  377   84.259    4.194   0.503
+clock.sjc.he.ne .CDMA.           1 u   41   64  377   23.634   -0.518   0.465
+SHM(0)          .GPS.            0 l   50   64  377    0.000    6.631   5.331
-----------------------------------------------------------------------------

If you are running PPS then it will look like this:

-----------------------------------------------------------------------------
     remote           refid      st t when poll reach   delay   offset  jitter
==============================================================================
xtime-a.timefreq .ACTS.           1 u   40   64  377   59.228   -8.503   0.516
-bonehed.lcs.mit 18.26.4.106      2 u   44   64  377   84.259    4.194   0.503
+clock.sjc.he.ne .CDMA.           1 u   41   64  377   23.634   -0.518   0.465
+SHM(0)          .GPS.            0 l   50   64  377    0.000    6.631   5.331
*SHM(1)          .GPS1.           0 l   49   64  377    0.000    0.222   0.310
-----------------------------------------------------------------------------

When the value under "reach" remains zero, check that gpsd is running;
cgps reports a 3D fix; and the '-n' option was used.  Some GPSes
specialized for time service can report time with signal lock on only
one satellite, but with most devices a 3D fix is required.

When the SHM(0) line does not appear at all, check your ntp.conf and
the system logs for error messages from ntpd.

Notice the 1st and 3rd servers, stratum 1 servers, disagree by more than
8 mSec.  The 1st and 2nd servers disagree by over 12 mSec.  Our local
PPS reference agrees to the clock.sjc.he.net server within the expected
jitter of the GR-601W in use.

When no other reference clocks appear in the NTP configuration, the
system clock will lock onto the GPS clock, but this is a fragile setup
- you can lose your only time reference if the GPS is temporarily
unable to get satellite lock.

You should always have at least two fallback chimers in your ntpd.conf
for proper ntpd operation, in case your GPS fails to report time. And
you'll need to adjust the offsets (fudges) in your ntp.conf so the
SHM(1) time is consistent with your other reference clocks. We'll
describe how to diagnose and tune your chimer configuration in a later
section.

The gpsd developers would like to receive information about the
offsets (fudges) observed by users for each type of receiver.  Please
check the GPS hardware table at <<HARDWARE>>; if your GPS is not
present or doesn't have a recommended fudge, send us the output of the
"ntpq -p" command and the make and type of receiver.

== Feeding chrony from GPSD ==

chrony is an alternative open-source implementation of NTP service,
originally designed for systems with low-bandwidth or intermittent
TCP/IP service.  It interoperates with ntpd using the same protocols,
but is somewhat easier to configure and administer.  Like ntpd, it can
either operate purely as a client or provide time service. The chrony
project has a home page at <<CHRONY>>.

gpsd can provide reference clock information to chronyd similarly to
the way it talks to ntpd.  The advantage to using chrony is that the
PPS time resolution is in nanoseconds.  This is 1,000 times more
precision than the microsecond time resolution provided to ntpd.  When
gpsd supports the new ntpd protocol this difference will disappear,
but chronyd is still simpler to set up.

gpsd, when run as root, talks to chronyd using a socket named
/var/run/chrony.ttyXX.sock (where ttyXX is replaced by the GPS device
name.  This allows multiple GPS to feed one chronyd.

No gpsd configuration is required to talk to chronyd.  To get chronyd
to connect to gpsd using the non-preferred SHM method add this to your
/etc/chrony/chrony.conf file:

-----------------------------------------------------------------------------
# delay 0.0 is right, but use 0.2 to avoid NMEA
# time fighting with PPS time
refclock SHM 0 offset 0.0 delay 0.2
refclock SHM 1 offset 0.0 delay 0.0
-----------------------------------------------------------------------------

To get chronyd to connect to gpsd using the more precise socket 
method add this to your /etc/chrony/chrony.conf file (replacing ttyXX
with your device name):  

If running as root:

-----------------------------------------------------------------------------
#refclock PPS
refclock SOCK /var/run/chrony.ttyXX.sock 
-----------------------------------------------------------------------------

If not running as root:  

-----------------------------------------------------------------------------
#refclock PPS
refclock SOCK /tmp/chrony.ttyXX.sock 
-----------------------------------------------------------------------------

== NTP performance tuning ==

For good time stability, you should always have at least four other
chimers in your ntpd or chrony configuration besides your GPS
- in case, for example, your GPS is temporarily unable to achieve
satellite lock, or has an attack of temporarity insanity. You can find
public NTP chimers to add to your configuration at <<USE-POOL>>. 

To minimize latency variations, use the national and regional pool
domains for your country and/or nearby ones.  Your configuration
line should probably look like this

-----------------------------------------------------------------------------
pool us.pool.ntp.org iburst
-----------------------------------------------------------------------------

where "us" may be replaced by one of the country codes the Pool
project supports. The "iburst" tag expands to four randomly chosen
servers. 

Note that a chimer can be a poor performer (what the inventor of NTP
whimsically calls a "falseticker") for either of two reasons. It may
be shipping bad time, or the best routes between you and it have large
latency variations.  (Large but fixed latencies can be compensated out
using a fudge.)

The standard tool for tuning is "ntpq" ("NTP query program"). To show a
list of all servers declared in ntp.conf and their statistics, invoke it
with the "-p" option. On a sample system configured with 7 servers from
the NTP pool project and one PPS GPS attached via RS232, this is the
output:
 
-----------------------------------------------------------------------------
$ ntpq -p
     remote           refid      st t when poll reach   delay   offset  jitter
==============================================================================
-mimir.fcom.ch   162.23.41.55     2 u   11   64  377    3.774   -0.276  11.866
-arthur.testserv 162.23.41.56     2 u   62   64  377    5.835   -1.129   8.921
-ntppublic.uzh.c 130.60.159.7     3 u   62   64  377    6.121   -4.102   6.336
-smtp.irtech.ch  162.23.41.56     2 u   35   64  377   15.521   -1.677   8.678
+time2.ethz.ch   .PPS.            1 u   27   64  377    5.938   -1.713  16.404
-callisto.mysnip 192.53.103.104   2 u   53   64  377   49.357   -0.274   5.125
-shore.naturalne 122.135.113.81   3 u   22   64  377   14.676   -0.528   2.601
-ntp.univ-angers 195.220.94.163   2 u   41   64  377   40.678   -1.847  13.391
+SHM(0)          .GPS.            0 l    4   64  377    0.000   34.682   7.952
*SHM(1)          .PPS.            0 l    3   64  377    0.000   -2.664   0.457
-----------------------------------------------------------------------------

The interesting columns are "remote", "st", "reach" and "offset".

"remote" is the name of the remote NTP server. The character in its
first column shows its current state: "-" or "x" for out-of-tolerance
servers, "+" for good servers ("truechimers"), and "*" for the one good
server currently used as the primary reference. The calculations used to
determine a server's state are outside the scope of this document;
details are available in RFCs 1305 and 5905.

"st" shows the remote server's stratum.

"reach" is the octal representation of the remote server's reachability.
A bit is set if the corresponding poll of the server was successful,
i.e. the server returned a reply. New poll results are shifted in from
the least significant bit; results older than 8 polls are discarded. In
the absence of network problems, this should show "377".

"offset" shows the mean offset in the times reported between this local
host and the remote server in milliseconds. This is the value that can
be fudged with the "time1" parameter of the GPS server line in ntp.conf.
If the offset is positive, reduce the time1 value and vice versa.

A more detailed description of the output is available at
<<NTPQ-OUTPUT>>.

TODO: There's an open issue about how you know you're stabilized
enough to compute a correct offset.

In order to determine the correct GPS offset, do the following:

1. Add these lines to ntp.conf:

-----------------------------------------------------------------------------
statsdir /var/log/ntpstats/
statistics peerstats
filegen peerstats file peerstats type day enable
-----------------------------------------------------------------------------

This enables logging of the peer server statistics.

2. Make sure the directory exists properly.  As root do:
   # mkdir -p /var/log/ntpstats
   # chown ntp:ntp /var/log/ntpstats

3. Start ntpd and let it run for at least four hours.

4. Calculate the average GPS offset using this script (a copy is
included as contrib/ntpoffset in the GPSD distribution):

-----------------------------------------------------------------------------
awk '
     /127\.127\.28\.0/ { sum += $5 * 1000; cnt++; }
     END { print sum / cnt; }
' </var/log/ntpstats/peerstats
-----------------------------------------------------------------------------

This prints the average offset.

5. Adjust the "time1" value for unit 0 of your ntp.conf (the non-PPS
   channel) by subtracting the average offset from step 4.

6. Restart ntpd.

== Providing public NTP service ==

<<NTP-FAQ>> has good advice on things to be sure you have done - and
are ready to do - before becoming a public chimer. One detail it
doesn't mention is that you'll need to un-firewall UDP port 123.

If and when you are ready to go public, see <<JOIN-POOL>>. 

== TODOs ==

Gary says:

I would also add the comments in ntpshm.c starting on lines 78 and 865.

ckuethe could contribute info on how this all works with BSD.

Hal says:

No, the servers are OK.  The problem is a buggy tool and/or a poor choice of
tool.  Try sntp -d xxx or ntpdate -d xxx  (ntpdate is depricated)

ntptrace calls ntpq which uses mode 6 packets.  That's the back door for
debugging/monitoring.  It's disabled (from the outside world) on many/most
ntpd servers that are exposed to the big/bad internet.  But when it works, it
gives text printout which is easier to parse from simple scripts.

# > There's a reference to it in a comment
# > in ntpshm.c, but it didn't tell me eniough to understand *why*.
#
# One very basic issue, is that the mechanism gpsd uses to communicate
# to ntpd or chronyd differs depending on whether gpsd is root or not.
#
# Note the code and coments in ntpshm.c starting on lines 190 and 664.
#
# Or just search for all usage of getuid() in ntpshm.c

== Acknowledgments ==
Beat Bolli <bbolli@ewanet.ch> wrote much of the section on NTP
performance tuning.

== References ==

[bibliography]
- [[[WIKI-NTP]]] http://en.wikipedia.org/wiki/Network_Time_Protocol[Network Time Protocol]

- [[[NTP-FAQ]]] http://www.ntp.org/ntpfaq/[NTP FAQ]

- [[[RFC-1305] http://www.ietf.org/rfc/rfc1305.txt[Network Time Protocol (Version 3)]

- [[[STRATA]]] http://www.endruntechnologies.com/stratum1.htm[What Is Stratum 1?]

- [[[HARDWARE]]] http://catb.org/gpsd/hardware.html[Compatible Hardware]

- [[UBLOX-TIMING]] http://www.u-blox.com/images/downloads/Product_Docs/Timing_AppNote_%28GPS.G6-X-11007%29.pdf[GPS-based timing considerations with u-blox 6 receivers]

- [[[NTP.ORG]]] http://www.ntp.org/[Home of the Network Time Protocol project]

- [[[USE-POOL]]] http://www.pool.ntp.org/en/use.html[How do I use pool.ntp.org?]

- [[[JOIN-POOL]]] http://www.pool.ntp.org/en/join.html[How do I join pool.ntp.org?]

- [[[CHRONY]]] http://chrony.tuxfamily.org/[Chrony Home]

- [[[NTPQ-OUTPUT]]] http://nlug.ml1.co.uk/2012/01/ntpq-p-output/831

- [[[SIRF-WOBBLE]]] http://www.megapathdsl.net/~hmurray/ntp/GPSSiRF-off.gif[Peer Offset of SiRF units]
